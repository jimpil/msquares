<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1456431409395">{:repl-history {:ide [], :local [&quot;(for [i (range 5)\n      j (range 5)]\n  i)&quot; &quot;(for [i (range 3)\n      j (range 3)]\n  i)&quot; &quot;(for [i (range 3)\n      j (range 3)]\n  [1 2 3])&quot; &quot;(for [i (range 3)\n      j (range 3)]\n  [i j])&quot; &quot;(for [i (range 3)]\n  [i j])&quot; &quot;(for [i (range 3)]\n  [i i])&quot; &quot;(for [i (range 2)]\n  (range i 2))&quot; &quot;(for [i (range 2)]\n  (range i 3))&quot; &quot;(for [i (range 3)]\n  (range i 3))&quot; &quot;(for [i (range 3)]\n  (range (* 3 i) (+ (* 3 i) 3)))&quot; &quot;(mod 3 2)&quot; &quot;(sum 3)&quot; &quot;(magic-constant 3)&quot; &quot;(long (+\n        (* 3\n           (mod (+ (/ 3 2)\n                   (dec (+ 1 1)))\n                3))\n        (inc (mod (- (+ 1\n                        (* 2 1))\n                     2)\n                  3))))&quot; &quot;(apply map vector [[8 1 6] [3 5 7] [4 9 2]])&quot; &quot;(/ 39 2)&quot; &quot;(mod 5 2)&quot; &quot;(long 7.5)&quot; &quot;(take 5 (iterate (partial + 2) 3))&quot; &quot;(odd-msquare 5\n             )&quot; &quot;(mod (+ 1 3/2) n)&quot; &quot;(+1 *1)&quot; &quot;(mod 2 3)&quot; &quot;(+ 2 17/2)&quot; &quot;(long 3/2)&quot; &quot;(* 3 3/2)&quot; &quot;(mod (+ 1 3/2) 3)&quot; &quot;(* 3 *1)&quot; &quot;(+ 1 *1)&quot; &quot;(mod 1 3)&quot; &quot;(+ 17/2 1)&quot; &quot;(long *1)&quot; &quot;(let [[mi mj :as middle] (repeat 2 (-&gt; (/ 3 2) long inc))]\n  (get-in [[8 1 6] [3 5 7] [4 9 2]] middle)\n  \n  \n  )&quot; &quot;(long (/ 3 2))&quot; &quot;(middle-no 3)&quot; &quot;(-&gt; (/ 3 2) long inc)&quot; &quot;(let [[mi mj :as middle] (repeat 2 (-&gt; (/ 3 2) long))]\n  (get-in [[8 1 6] [3 5 7] [4 9 2]] middle)\n  \n  \n  )&quot; &quot;(odd-msquare 9)&quot; &quot;(odd-msquare 13)&quot; &quot;(odd-msquare 21)&quot; &quot;(odd-msquare 71)&quot; &quot;(odd-msquare 1)&quot; &quot;(odd-msquare -3)&quot; &quot;(odd-msquare 7)&quot; &quot;(/ 32 4)&quot; &quot;(/ 32 2)&quot; &quot;(/ (- 8 4) 2)&quot; &quot;(for [i (range 5)\n      j (range 5)]\n  [i j])&quot; &quot;(partition 2 (range 1 (inc (* 2 8))))&quot; &quot;(partition 8 (range 1 (inc (* 2 8))))&quot; &quot;(initial-marks 32)&quot; &quot;(-&gt;&gt; *1 last reverse (drop-while nil?) first)&quot; &quot;(initial-marks 8)&quot; &quot;(initial-step 8)&quot; &quot;(initial-step 4)&quot; &quot;(initial-step 32)&quot; &quot;(doubly-even-msquare 8)&quot; &quot;(doubly-even-msquare 4)&quot; &quot;(doubly-even-msquare 12)&quot; &quot;(map #(apply + %) *1)&quot; &quot;(map #(apply + ut/transpose) *2)&quot; &quot;(map #(apply + (ut/transpose %) *2)&quot; &quot;(map #(apply + (ut/transpose %)) *2)&quot; &quot;(map #(apply + (ut/transpose %)) *3)&quot; &quot;(map #(apply + (ut/transpose %)) *1)&quot; &quot;(doubly-even-msquare 32)&quot; &quot;(map #(apply + %) (ut/transpose *1))&quot; &quot;(odd-msquare 10)&quot; &quot;(odd-msquare 3 10)&quot; &quot;(map #(map (partial + 9) %) *1)&quot; &quot;(update [8 1 6] 0 (constantly 8))&quot; &quot;(update [8 1 6] 0 (constantly -9))&quot; &quot;(singly-even-msquare 6)&quot; &quot;(singly-even-msquare 10)&quot; &quot;(singly-even-msquare 12)&quot; &quot;(ut/test-square magic? *1)&quot; &quot;(ut/test-square magic? (singly-even-msquare 6))&quot; &quot;(ut/test-square magic? (singly-even-msquare 10))&quot; &quot;(ut/test-square magic? (singly-even-msquare 14))&quot; &quot;(ut/test-square magic? (singly-even-msquare 16))&quot; &quot;(ut/test-square magic? (singly-even-msquare 18))&quot; &quot;(ut/test-square magic? (singly-even-msquare 20))&quot; &quot;(ut/test-square magic? (singly-even-msquare 22))&quot; &quot;(ut/test-square magic? (doubly-even-msquare 4))&quot; &quot;(ut/test-square magic? (doubly-even-msquare 6))&quot; &quot;(ut/test-square magic? (doubly-even-msquare 8))&quot; &quot;(ut/test-square magic? (doubly-even-msquare 12))&quot; &quot;(ut/test-square magic? (doubly-even-msquare 16))&quot; &quot;(singly-even-msquare 14)&quot; &quot;(clojure.stacktrace/e)&quot; &quot;(ut/diagonals (odd-msquare 3))&quot; &quot;(ut/diagonals [[1 2 3] [4 5 6] [7 8 9]])&quot; &quot;(odd-msquare 3)&quot; &quot;(odd-msquare 5)&quot; &quot;(doubly-even-msquare 16)&quot;], :remote []}}</component>
</project>